import de.undercouch.gradle.tasks.download.Download

plugins {
    id 'java'
    id 'application'
//    pulls the correct platform dependent native libraries onto the classpath
    id 'org.openjfx.javafxplugin' version '0.1.0'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'org.beryx.jlink' version '3.0.1'
    id "de.undercouch.download" version "4.1.1"
}

group = 'io.github.vincemann'
version = '1.1.0'


application {
    mainModule = 'io.github.vincemann.subtitlebuddy'
    mainClass = 'io.github.vincemann.subtitlebuddy.Main'
}

ext {
    // Use the provided targetPlatform property if available, otherwise use the detected OS
    // Options are [linux | win | mac | mac-aarch64 ]
    targetPlatform = project.hasProperty('targetPlatform') ? project.targetPlatform : detectOS()
    println("target platform detected: " + targetPlatform)
    releaseDir = "${projectDir}/build/releases"
}

static def detectOS() {
    def os = org.gradle.internal.os.OperatingSystem.current()
    println("Operating system detected: " + os)
    if (os.isWindows()) {
        println("Detected Windows OS")
        return "win"
    } else if (os.isLinux()) {
        println("Detected Linux OS")
        return "linux"
    } else if (os.isMacOsX()) {
        def arch = System.getProperty("os.arch")
        println("Detected macOS with architecture: " + arch)
        if (arch.contains("aarch64") || arch.contains("arm64")) {
            println("Detected ARM architecture")
            return "mac-aarch64"
        } else {
            return "mac"
        }
    }
    throw new GradleException("Cannot evaluate current OS")
}


javafx {
    version = "17"
    modules = ['javafx.controls', 'javafx.fxml']
    platform = targetPlatform
}


test {
    // Set this to true to capture printed output during tests
    testLogging.showStandardStreams = true

    // Configure which events get logged
    testLogging {
        events "passed", "skipped", "failed", "standardOut", "standardError"
        // To show detailed exception messages and stack traces in the console
        exceptionFormat "full"
    }
    doFirst {
        // Initialize the list with common JVM arguments
        List<String> args = [
                '--add-modules', javafx.modules.join(","),
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED',
                '--add-exports', 'javafx.graphics/com.sun.javafx.application=org.testfx',
                '--add-exports', 'java.desktop/com.apple.eawt=io.github.vincemann.subtitlebuddy',
                '--add-opens', 'javafx.graphics/com.sun.javafx.application=org.testfx'
        ]
        // win always fails to pick stuff up from within fat jar or cp/modulepath
        if (project.targetPlatform == 'win') {
            println("adding win javafx modules to module path")
            args += ['--module-path', "${projectDir}/lib/javafx/win/jmods"]
        }

        else if (project.targetPlatform.startsWith('mac')) {
            args += ['--add-exports', 'java.desktop/com.apple.eawt=io.github.vincemann.merged.module']
            // doesnt seem to be needed - native libs are picked up from classpath/modulepath
//            println("adding osx javafx modules to module path")
//            args += ['--module-path', "${projectDir}/lib/javafx/osx/jmods"]
        }

        // Assign the constructed argument list to jvmArgs
        jvmArgs = args
    }
}


// copies native jnativehook libraries into the image, which can be picked up by JLinkJNativeLibraryLocator
tasks.register("copyNativeLibs", Copy) {
    mustRunAfter "jlink"
    doFirst {
        // Clean the destination directory before copying new files
        delete "${projectDir}/build/image/appLauncher-${targetPlatform}/lib/jnativehook"
    }
    from "${projectDir}/lib/jnativehook"
    into "${projectDir}/build/image/appLauncher-${targetPlatform}/lib/jnativehook"
    doLast {
        println "Native libraries copied to ${projectDir}/build/image/appLauncher-${targetPlatform}/lib/jnativehook"
    }
}

// creates ./build/image-platform.zip
tasks.named('jlinkZip').configure {
    dependsOn 'jlink'
    dependsOn 'copyWinStartScript'
    dependsOn 'copyNativeLibs'
}

// copy start script generated by jlink to correct location to be picked up by inno, when createWindowsInstaller called
// only relevant when building win jlink image and then createWindowsInstaller on linux host
tasks.register("copyWinStartScript", Copy) {

    onlyIf { project.targetPlatform == 'win' }

    doFirst {
        if (project.targetPlatform != 'win') {
            logger.lifecycle("Skipping copyWinStartScript as the target platform is not Windows.")
        } else {
            delete "${projectDir}/releases/windows/x64/inno/start.bat"
        }
    }

    mustRunAfter "jlink"
    from("${projectDir}/build/image/appLauncher-win/bin/appLauncher.bat") {
        rename { 'start.bat' }
    }
    into "${projectDir}/releases/windows/x64/inno"

    doLast {
        println "Win start script copied to ${projectDir}/releases/windows/x64/inno"
    }
}

tasks.named('jlink').configure {
    finalizedBy 'copyWinStartScript', 'copyNativeLibs'
}

tasks.register('repackageMacApp', Exec) {
    onlyIf { project.targetPlatform.startsWith('mac') }
    mustRunAfter 'jpackage'
    def originalAppPath = "${jpackage.getJpackageData().installerOutputDir}/subtitle-buddy.app"
    println("Original app path: ${originalAppPath}")

    doFirst {
        if (!project.targetPlatform.startsWith('mac')) {
            logger.lifecycle("Skipping repackageMacApp as the target platform is not macOS.")
            return
        }

        // Define the binary and symlink target paths
        def binaryPath = new File(originalAppPath, "Contents/MacOS/subtitle-buddy")
        def targetPath = "../runtime/Contents/Home/bin/appLauncher" // Relative path from the binary location

        // Remove the original binary if it exists
        if (binaryPath.exists()) {
            binaryPath.delete() // Delete the original binary
            println "Original binary deleted."
        }

        // Create the symlink command
        commandLine 'ln', '-s', targetPath, binaryPath.name
        workingDir = binaryPath.parentFile

        println "Symlink command set up to replace the original binary."
    }

    doLast {
        println "Repackaging of macOS app completed."
    }
}



// builds platform specific jlink images in build/images
// NOTE: for mac this only works, when building on mac for whatever reason - otherwise it will segfault
jlink {
    options = [
            '--strip-debug',
            '--compress', '2',
            '--no-header-files',
            '--no-man-pages'
    ]


    switch (targetPlatform) {
        case 'linux':
            targetPlatform("linux") {
                jdkHome = jdkDownload('https://github.com/AdoptOpenJDK/openjdk17-binaries/releases/download/jdk-2021-05-07-13-31/OpenJDK-jdk_x64_linux_hotspot_2021-05-06-23-30.tar.gz')
            }
            // use jpackage to build deb installer
            if (detectOS() == 'linux') {
                jpackage {
                    targetPlatformName = "linux"
                    icon = "${projectDir}/icons/icon.png"
                    imageName = "subtitle-buddy"
                    installerName = "subtitle-buddy"
                    vendor = "vincemann"
                    installerOptions = [
                            '--linux-deb-maintainer', 'v.conrad98@web.de',
                            '--linux-menu-group', 'Applications',
                    ]
                    // add post installation script for creating a symlink after installation
                    resourceDir = file("${projectDir}/releases/linux/deb")
                    println("resource dir: ${resourceDir.getPath()}")
                    installerType = 'deb'
                }
            }
            break
        case 'win':
            targetPlatform("win") {
                jdkHome = jdkDownload('https://github.com/AdoptOpenJDK/openjdk17-binaries/releases/download/jdk-2021-05-07-13-31/OpenJDK-jdk_x64_windows_hotspot_2021-05-06-23-30.zip')
                addExtraModulePath("${projectDir}/lib/javafx/win/jmods")
            }
            if (detectOS() == 'win') {
                jpackage {
                    targetPlatformName = "win"
                    icon = "${projectDir}/icons/icon.ico"
                    imageName = "subtitle-buddy"
                    installerName = "subtitle-buddy"
                    vendor = "vincemann"
                    installerOptions = ['--win-menu', '--win-shortcut']
                    installerType = 'msi'
                }
            }
            break
        case 'mac':
            targetPlatform("mac") {
                jdkHome = jdkDownload('https://github.com/AdoptOpenJDK/openjdk17-binaries/releases/download/jdk-2021-05-07-13-31/OpenJDK-jdk_x64_mac_hotspot_2021-05-06-23-30.tar.gz')
                addExtraModulePath("${projectDir}/lib/javafx/osx/x86/jmods")
            }
            // use jpackage to build dmg and app files, only works when also building on mac
            if (detectOS() == 'mac') {
                jpackage {
                    targetPlatformName = "mac"
                    imageName = "subtitle-buddy"
                    installerName = "subtitle-buddy"
                    installerName = "subtitle-buddy"
                    icon = "${projectDir}/icons/icon.icns"
                    vendor = "vincemann"
                }
            }
            break
        case 'mac-aarch64':
            targetPlatform("mac") {
                jdkHome = jdkDownload('https://github.com/AdoptOpenJDK/openjdk17-binaries/releases/download/jdk-2021-05-07-13-31/OpenJDK-jdk_arm64_mac_hotspot_2021-05-06-23-30.tar.gz')
                addExtraModulePath("${projectDir}/lib/javafx/osx/arm/jmods")
            }
            // use jpackage to build dmg and app files, only works when also building on mac
            if (detectOS() == 'mac-aarch64') {
                jpackage {
                    targetPlatformName = "mac"
                    imageName = "subtitle-buddy"
                    installerName = "subtitle-buddy"
                    icon = "${projectDir}/icons/icon.icns"
                    vendor = "vincemann"
                }
            }
            break
        default:
            throw new GradleException("need to specify target platform")
    }

    launcher {
        name = 'appLauncher'
        mainClass = application.mainClass.get()
        forceMerge('log4j-api')
        // fixes : package org.apache.commons.logging is declared in module org.apache.commons.logging, but module io.github.vincemann.merged.module does not read it
        forceMerge('commons-logging')
        // make sure symlinks work when installed via homebrew and more
        unixScriptTemplate = new File("${projectDir}/releases/linux/appLauncher")
        windowsScriptTemplate = new File("${projectDir}/releases/windows/start.bat")
        jvmArgs = [
                // tells application to use the jlink lib locator for jnativehook
                '-Djlink=true',
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED',
                '--add-reads', 'io.github.vincemann.merged.module=org.apache.commons.logging',
                '--add-reads', 'org.apache.commons.configuration2=io.github.vincemann.merged.module',
                '--add-exports', 'java.desktop/com.apple.eawt=io.github.vincemann.merged.module'
//                "--add-exports", "org.apache.commons.logging/org.apache.commons.logging=org.apache.commons.configuration2"
        ]
    }

}

// somehow jpackage does not include my postinst script, so I need to repackage the deb package myself
// also I need to replace the startup binary with a symlink, bc otherwise my liblocator for jnativehook breaks
tasks.register('repackageDeb', Exec) {
    onlyIf { project.targetPlatform == 'linux' }
    mustRunAfter 'jpackage'
    def originalDeb = "${jpackage.getJpackageData().installerOutputDir}/subtitle-buddy_1.1.0-1_amd64.deb" // there is no var to retrieve the installer name from
    println("original deb: ${originalDeb}")
    def tempDir = "${projectDir}/build/deb-temp"

    // put postinst data into deb-temp

    doFirst {
        if (project.targetPlatform != 'linux') {
            logger.lifecycle("Skipping repackageDeb as the target platform is not Linux.")
            return
        }

        // Ensure the temp directory is clean
        delete tempDir

        // Unpack the original DEB
        commandLine 'dpkg-deb', '-R', originalDeb, tempDir
    }
    doLast {

        // I dont want a binary created in bin folder, bc that breaks my JLinkLibLocator,
        // instead replace with symlink to runtime start script
        def binDir = new File(tempDir, '/opt/subtitle-buddy/bin')
        def originalBinary = new File(binDir, 'subtitle-buddy')
        if (originalBinary.exists()) {
            originalBinary.delete() // Delete the original binary
        }

        // Create a symlink
        exec {
            workingDir = binDir
            commandLine 'ln', '-s', '../lib/runtime/bin/appLauncher', 'subtitle-buddy'
        }

        // Ensure the DEBIAN directory exists
        def debianDir = new File(tempDir, 'DEBIAN')
        def postinstScript = "$projectDir/releases/linux/deb/DEBIAN/postinst"

        // Check if postinst already exists and delete if necessary
        def postinstFile = new File(debianDir, 'postinst')
        if (postinstFile.exists()) {
            println "postinst script already exists, overwriting..."
            postinstFile.delete()
        }
        // Copy the postinst script
        copy {
            from postinstScript
            into debianDir
            fileMode 0755
        }
        // Define the modified package path
        def modifiedDeb = "${projectDir}/build/jpackage/subtitle-buddy-modified.deb"

        // delete the old deb package
        delete originalDeb

        // Repackage the DEB
        exec {
            commandLine 'dpkg-deb', '-b', tempDir, modifiedDeb
        }


        // Log the completion
        println "Modified DEB package created at: $modifiedDeb"
    }
}

tasks.named('jpackageImage').configure {
    dependsOn 'copyWinStartScript', 'copyNativeLibs'
    finalizedBy 'repackageMacApp'
    finalizedBy 'repackageMacApp'
}

tasks.named('jpackage').configure {
    finalizedBy 'repackageDeb'
}

def appImageToolUrl = 'https://github.com/AppImage/appimagetool/releases/download/continuous/appimagetool-x86_64.AppImage'
def appImageToolPath = "${projectDir}/releases/linux/appimagetool.AppImage"

tasks.register('downloadAppImageTool', Download) {
    src appImageToolUrl
    dest appImageToolPath
    onlyIfNewer true
    doLast {
        file(appImageToolPath).setExecutable(true)
    }
}

// uses app image tool generating binary, which must be placed into: releases/linux/appimagetool.AppImage
// execute with -PtargetPlatform=linux
tasks.register('buildLinuxAppImage') {
    dependsOn('jlink', 'downloadAppImageTool')
    doFirst {
        mkdir releaseDir
    }
    doLast {
        if (targetPlatform != "linux") {
            throw new GradleException("Need to specify linux target platform or run on linux")
        }
        // Define version and paths
        def baseDir = "${projectDir}/releases/linux/x64"
        def imageName = "subtitle-buddy-${version}-linuxx64.AppImage"
        def linuxImagePath = "${releaseDir}/${imageName}"
        def appImagePath = "${baseDir}/SubtitleBuddy.AppDir/usr/image"
        def jlinkImagePath = "${projectDir}/build/image/appLauncher-linux"  // Path to the jlink runtime image

        // Prepare AppDir for AppImage
        println "Preparing AppDir with jlink image..."
        delete appImagePath  // Clear the previous contents
        mkdir appImagePath
        copy {
            from "$jlinkImagePath"  // Copy runtime image created by jlink
            into appImagePath
        }
        println "jlink runtime image copied"

        // Build AppImage
        println "Building AppImage..."
        exec {
            environment "ARCH", "x86_64"
            commandLine 'bash', '-c', "cd ${baseDir} && ../appimagetool.AppImage SubtitleBuddy.AppDir $linuxImagePath"
        }
        println "AppImage created at $linuxImagePath"
        println "Done with linux x64 AppImage build"
    }
}

// used for creating installer for windows running on linux host system
// when building installer from win for win, better run 'gradlew.bat clean jpackage'
// uses a docker container with image name 'amake/innosetup' that uses wine for building windows installer from linux host machines
// execute with -PtargetPlatform=win
tasks.register('buildWindowsInstaller') {
    dependsOn('jlink')
    if (targetPlatform != "win") {
        throw new GradleException("Need to specify win target platform")
    }
    def os = detectOS()
    if (os == "win") {
        throw new GradleException("This task is meant for building windows installer on a linux host machine. " +
                "For building on windows use 'gradlew.bat clean jpackage'")
    }
    doFirst {
        mkdir releaseDir
    }
    doLast {
        def baseDir = "${projectDir}/releases/windows/x64"
        def installerBaseDir = "${baseDir}/inno"
        def outputExeName = "subtitle-buddy-installer.exe"
        def installerName = "subtitle-buddy-${version}-windowsx64-installer.exe"
        def outputExePath = "${installerBaseDir}/output/${outputExeName}"
        def appImagePath = "${installerBaseDir}/image"
        def jlinkImagePath = "${projectDir}/build/image/appLauncher-win" // Path to the jlink runtime image

        // Ensure target directories exist
        file(installerBaseDir).mkdirs()

        // Deploy the jlink image to the installer directory
        delete "$appImagePath"
        mkdir "$appImagePath"
        copy {
            from "$jlinkImagePath" // Copy runtime image created by jlink
            into "$appImagePath"
        }
        println "Deployed jlink runtime image to installer directory"


        // Building the installer using Inno Setup within a Docker container
        println "Building installer"
        exec {
            commandLine 'bash', '-c', "cd ${installerBaseDir} && docker run --rm -v \"\$PWD:/work\" amake/innosetup subtitle-buddy.iss"
        }

        def installerPath = "${releaseDir}/${installerName}"
        delete installerPath
        copy {
            from "${installerBaseDir}/output/${outputExeName}"
            into "${releaseDir}"
            rename { String fileName ->
                installerName
            }
        }
        delete outputExePath
        println "Installer created at ${installerPath}"
    }
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
    modularity.inferModulePath.set(true)
}

// builds fat jar containing javafx moules and all other deps
// in windows and macos jmods of javafx need to be shipped and declared in module path anyways
// after building, jar can be launched like this (if jdk17 is installed):
// linux:   java --add-modules javafx.controls,javafx.fxml -jar /path/to/myjar.jar
// osx:     java --module-path lib/javafx/osx/x86/sdk/lib --add-modules javafx.controls,javafx.fxml -jar /path/to/myjar.jar
// win:     java --module-path lib/javafx/win/jmods --add-modules javafx.controls,javafx.fxml -jar /path/to/myjar.jar
// ( note that osx seems to need sdk jars and not jmods )
// Download: https://gluonhq.com/products/javafx/
shadowJar {
    archiveClassifier.set('')
    archiveFileName = "subtitle-buddy-${version}-${targetPlatform}.jar"
    manifest {
        attributes 'Main-Class': application.getMainClass().get()
    }
    mergeServiceFiles {}
    // this removes needed classes for slf4j, making dynamic class loading of slf4j impl fail
    // also the default jlink native lib loader probably wont work as well
    // todo configure minimize with exceptions
//    minimize()  // Optional: minimize the jar to remove unused classes
}

repositories {
    mavenCentral()
}


run {
    doFirst {
        // Initialize the list with common JVM arguments
        List<String> args = [
                // modules are not part of sdk anymore - need to add them manually to module graph
                "--add-modules", javafx.modules.join(","),
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED'
//                "--add-exports", "org.apache.commons.logging/org.apache.commons.logging.impl=org.apache.commons.configuration2"
        ]

        // Conditionally add module-path based on the target platform
        if (project.targetPlatform == 'win') {
            println("adding win javafx modules to module path")
            args += ['--module-path', "${projectDir}/lib/javafx/win/jmods"]
        }
        else if (project.targetPlatform == 'mac') {
            println("adding osx javafx modules to module path")
            args += ['--add-exports', 'java.desktop/com.apple.eawt=io.github.vincemann.subtitlebuddy']
            args += ['--module-path', "${projectDir}/lib/javafx/osx/x86/jmods"]
        }
        else if (project.targetPlatform == 'mac-aarch64') {
            println("adding osx javafx modules to module path")
            args += ['--add-exports', 'java.desktop/com.apple.eawt=io.github.vincemann.subtitlebuddy']
            args += ['--module-path', "${projectDir}/lib/javafx/osx/arm/jmods"]
        }

        jvmArgs = args
    }
}

dependencies {

    // capture mouse and keyboard events
    implementation 'com.github.kwhat:jnativehook:2.2.2'

    // di
    implementation('com.google.inject:guice:7.0.0')
    implementation('com.google.inject.extensions:guice-assistedinject:7.0.0')
    implementation('com.google.inject.extensions:guice-multibindings:4.2.3')
    implementation('commons-io:commons-io:2.16.1')

    // logging
    // using a version here that works with jlink plugin
    implementation 'org.apache.logging.log4j:log4j-api:2.11.1'
    implementation 'org.apache.logging.log4j:log4j-core:2.11.1'
    // route apache commons logging to log4j2 (commons configuration depends on using commons logging)
    runtimeOnly 'org.apache.logging.log4j:log4j-jcl:2.14.0'


    // event handling
    // using non modularized and same version that guice is using for max compatibility
    // when using latest jpms version here, some classes needed by guice are missing
    implementation('com.google.guava:guava:31.0.1-jre')

    // utils
    compileOnly 'org.projectlombok:lombok:1.18.28'
    annotationProcessor 'org.projectlombok:lombok:1.18.28'
    implementation('org.apache.commons:commons-configuration2:2.10.1')
    implementation('org.apache.commons:commons-lang3:3.12.0')
    // commons configuration 2 depends on this, but does not provide it
    implementation('commons-beanutils:commons-beanutils:1.9.4') {
        exclude group: 'commons-logging', module: 'commons-logging'
    }

    // detect encoding
    implementation 'com.ibm.icu:icu4j:75.1'


    // testing
    testImplementation('org.testfx:testfx-core:4.0.18') {
        exclude module: 'hamcrest-all'
    }
    testImplementation('org.testfx:testfx-junit:4.0.18') {
        exclude module: 'hamcrest-core'
    }
    testImplementation('org.loadui:testFx:3.1.2')
    testImplementation('org.hamcrest:hamcrest-core:1.3')

    testImplementation 'org.mockito:mockito-core:5.12.0'


    testImplementation 'junit:junit:4.13.2'
}
