
plugins {
    id 'java'
    id 'application'
//    pulls the correct platform dependent native libraries onto the classpath path
    id 'org.openjfx.javafxplugin' version '0.1.0'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'org.beryx.jlink' version '2.24.0'
}

group = 'io.github.vincemann'
version = '1.1.0'


application {
    mainModule = 'io.github.vincemann.subtitlebuddy'
    mainClass = 'io.github.vincemann.subtitlebuddy.Main'
}

ext {
    // Use the provided targetPlatform property if available, otherwise use the detected OS
    targetPlatform = project.hasProperty('targetPlatform') ? project.targetPlatform : evalCurrentOs()
    releaseDir = "${projectDir}/build/releases"
}

static def evalCurrentOs() {
    def os = org.gradle.internal.os.OperatingSystem.current()
    if (os.isWindows()) {
        return "win"
    } else if (os.isLinux()) {
        return "linux"
    } else if (os.isMacOsX()) {
        return "mac"
    }
    throw new GradleException("cant eval current os")
}


javafx {
    version = "17"
    modules = ['javafx.controls', 'javafx.fxml']
    platform = targetPlatform
}


test {
    doFirst {
        jvmArgs = [
                '--add-modules', javafx.modules.join(","),
                // windows does not recognize javafx deps, that's why I need to manually ship the native javafx jmods with it
                // and setup the module path in testing and when running the fat jar on windows
                // when running on other platforms this is ignored silently
                '--module-path', "${projectDir}/lib/javafx/win",
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED',
                "--add-exports", "org.apache.commons.logging/org.apache.commons.logging.impl=org.apache.commons.configuration2",
                '--add-exports', 'javafx.graphics/com.sun.javafx.application=org.testfx',
                '--add-opens', 'javafx.graphics/com.sun.javafx.application=org.testfx',

        ]
    }
}

// builds platform specific jlink images in build/images
jlink {
    options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']


    switch (project.ext.targetPlatform) {
        case 'linux':
            println("building jlink image for linux")
            targetPlatform("linux") {
                jdkHome = jdkDownload('https://github.com/AdoptOpenJDK/openjdk17-binaries/releases/download/jdk-2021-05-07-13-31/OpenJDK-jdk_x64_linux_hotspot_2021-05-06-23-30.tar.gz')
            }
            break
        case 'win':
            println("building jlink image for windows")

            targetPlatform("win") {
                jdkHome = jdkDownload('https://github.com/AdoptOpenJDK/openjdk17-binaries/releases/download/jdk-2021-05-07-13-31/OpenJDK-jdk_x64_windows_hotspot_2021-05-06-23-30.zip')
                addExtraModulePath("${projectDir}/lib/javafx/win")
            }
            break
        case 'mac':
            println("building jlink image for mac")
            targetPlatform("mac") {
                jdkHome = jdkDownload('https://github.com/AdoptOpenJDK/openjdk17-binaries/releases/download/jdk-2021-05-07-13-31/OpenJDK-jdk_x64_mac_hotspot_2021-05-06-23-30.tar.gz')
            }
            break
            throw new GradleException("need to specify target platform")
    }

    launcher {
        name = 'appLauncher'
        mainClass = application.mainClass.get()
        // make sure symlinks work when installed via homebrew
        unixScriptTemplate = new File("${projectDir}/releases/linux/appLauncher")
        forceMerge('log4j-api')
        jvmArgs = [
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED',
                '--add-reads', 'io.github.vincemann.merged.module=org.apache.commons.logging',
                '--add-reads', 'org.apache.commons.configuration2=io.github.vincemann.merged.module',
                "--add-exports", "org.apache.commons.logging/org.apache.commons.logging.impl=org.apache.commons.configuration2"
        ]
    }
}

// creates tarball for jlink image and stores in build dir
// execute with -PtargetPlatform=[linux,mac,win]
tasks.register('tarJlink', Exec) {
    dependsOn 'jlink'
    def version = project.version

    // Set the working directory and define the tarball path outside the doFirst
    workingDir "${projectDir}/build/image/appLauncher-${project.ext.targetPlatform}"
    def tarballPath = "${project.ext.releaseDir}/subtitle-buddy-$version-${project.ext.targetPlatform}.tar.gz"

    doFirst {
        // Ensure any previous tarball is deleted before creating a new one
        delete tarballPath
        mkdir project.ext.releaseDir
    }

    // Define the command line to execute within the main configuration block
    commandLine 'tar', '-czvf', tarballPath, '.', '--transform=s,^./,image/,'

    // Capture and print the output
    standardOutput = new ByteArrayOutputStream()
    errorOutput = new ByteArrayOutputStream()
    doLast {
        println("STDOUT: ${standardOutput.toString()}")
        println("STDERR: ${errorOutput.toString()}")
    }
}



// uses app image tool generating binary, which must be placed into: releases/linux/appimagetool.AppImage
// execute with -PtargetPlatform=linux
tasks.register('buildLinuxAppImage') {
    dependsOn('jlink')
    doFirst {
        mkdir project.ext.releaseDir
    }
    doLast {
        if (project.ext.targetPlatform != "linux"){
            throw new GradleException("Need to specify linux target platform or run on linux")
        }
        // Define version and paths
        def version = project.version
        def baseDir = "${projectDir}/releases/linux/x64"
        def linuxImageName = "subtitle-buddy-$version-linux-x64.AppImage"
        def linuxImagePath = "${project.ext.releaseDir}/${linuxImageName}"
        def appImagePath = "${baseDir}/SubtitleBuddy.AppDir/usr/image"
        def jlinkImagePath = "${projectDir}/build/image/appLauncher-linux"  // Path to the jlink runtime image

        // Prepare AppDir for AppImage
        println "Preparing AppDir with jlink image..."
        delete appImagePath  // Clear the previous contents
        mkdir appImagePath
        copy {
            from "$jlinkImagePath"  // Copy runtime image created by jlink
            into appImagePath
        }
        println "jlink runtime image copied"

        // Build AppImage
        println "Building AppImage..."
        exec {
            environment "ARCH", "x86_64"
            commandLine 'bash', '-c', "cd ${baseDir} && ../appimagetool.AppImage SubtitleBuddy.AppDir $linuxImagePath"
        }
        println "AppImage created at $linuxImagePath"
        println "Done with linux x64 AppImage build"
    }
}

// uses a docker container with image name 'amake/innosetup' that uses wine for building windows installer from linux host machines
// execute with -PtargetPlatform=win
tasks.register('buildWindowsInstaller') {
    dependsOn('jlink')
    if (project.ext.targetPlatform != "win"){
        throw new GradleException("Need to specify win target platform or run on win")
    }
    doFirst {
        mkdir project.ext.releaseDir
    }
    doLast {
        def version = project.version
        def baseDir = "${projectDir}/releases/windows/x64"
        def installerBaseDir = "${baseDir}/inno"
        def outputExeName = "subtitle-buddy-installer.exe"
        def installerName = "subtitle-buddy-$version-windowsx64-installer.exe"
        def outputExePath = "${installerBaseDir}/output/${outputExeName}"
        def appImagePath = "${installerBaseDir}/image"
        def jlinkImagePath = "${projectDir}/build/image/appLauncher-win" // Path to the jlink runtime image

        println "Version: $version"

        // Ensure target directories exist
        file(installerBaseDir).mkdirs()

        // Deploy the jlink image to the installer directory
        delete "$appImagePath"
        mkdir "$appImagePath"
        copy {
            from "$jlinkImagePath" // Copy runtime image created by jlink
            into "$appImagePath"
        }
        println "Deployed jlink runtime image to installer directory"

        // Building the installer using Inno Setup within a Docker container
        println "Building installer"
        exec {
            commandLine 'bash', '-c', "cd ${installerBaseDir} && docker run --rm -v \"\$PWD:/work\" amake/innosetup subtitle-buddy.iss"
        }

        def installerPath = "${project.ext.releaseDir}/${installerName}"
        delete installerPath
        copy {
            from "${installerBaseDir}/output/${outputExeName}"
            into "${project.ext.releaseDir}"
            rename { String fileName ->
                installerName
            }
        }
        delete outputExePath
        println "Installer created at ${installerPath}"
    }
}


// uses genisoimage linux cli tool, need to install it first
// execute with -PtargetPlatform=mac
tasks.register('buildMacDmg') {
    dependsOn 'jlink' // Ensure this task runs after the jlink image is created
    if (project.ext.targetPlatform != "mac"){
        throw new GradleException("Need to specify mac target platform or run on mac")
    }
    doLast {
        def version = project.version
        def baseDir = "${projectDir}/releases/macos/x64"
        def imagePath = "${baseDir}/SubtitleBuddy.app/Contents/Java/image"
        def dmgName = "subtitle-buddy-$version-macos-x64.dmg"
        def dmgOutputPath = "${baseDir}/$dmgName"
        def jlinkImagePath = "${projectDir}/build/image/appLauncher-mac" // Path to the jlink runtime image

        println "Version: $version"
        println "jlink Image Path: $jlinkImagePath"

        // Ensure the application directory exists
        file(imagePath).mkdirs()

        // Copy the jlink image to the application directory
        println "Deploying jlink runtime image to application directory..."
        delete imagePath
        mkdir imagePath
        copy {
            from jlinkImagePath
            into imagePath
        }
        println "jlink runtime image copied"

        // Build DMG
        println "Building DMG image..."
        exec {
            commandLine 'bash', '-c', "cd ${baseDir} && genisoimage -D -V 'Subtitle Buddy' -no-pad -r -apple -o ${dmgOutputPath} SubtitleBuddy.app/"
        }
        println "DMG created at $dmgOutputPath"
        println "Done with macOS x64"
    }
}



java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
    modularity.inferModulePath.set(true)
}

// build fat jar containing javafx moudles and all other deps
// in wwid oensnv jmods of javafx need to be shipped and declared anyways
shadowJar {
    archiveClassifier.set('')
    archiveFileName = "SubtitleBuddy-${project.version}-${targetPlatform}.jar"
    manifest {
        attributes 'Main-Class': application.getMainClass().get()
    }
    mergeServiceFiles {}
    // this removes needed classes for slf4j, making dynamic class loading of slf4j impl fail
//    minimize()  // Optional: minimize the jar to remove unused classes
}

repositories {
    mavenCentral()
    maven {
        url "https://jpms.pkg.st/repository"
    }
}

// same as: java --add-modules javafx.controls,javafx.fxml -jar /path/to/myjar.jar
// in windows this command in cli is needed java --module-path /path/to/javafx-sdk/lib --add-modules javafx.controls,javafx.fxml -jar /path/to/myjar.jar
run {
    doFirst {
        jvmArgs = [
                // modules are not part of sdk anymore - need to add them manually to module graph
                "--add-modules", javafx.modules.join(","),
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED',
                "--add-exports", "org.apache.commons.logging/org.apache.commons.logging.impl=org.apache.commons.configuration2"
        ]
    }
}

dependencies {

    // capture mouse and keyboard events
//    implementation 'com.1stleg:jnativehook:2.0.2'

    // need to use old version bc of segfaults on linux + keyboard strokes not working
    // needed to self modularize the jar in order to include for whatever reason + this way I can build a custom jlink image
    // bc cant use automatic modules in jlink
    implementation files('lib/jnativehook-2.0.2-patched.jar')

    // dependency injection
    implementation('com.google.inject:guice:7.0.0')
    implementation('com.google.inject.extensions:guice-assistedinject:7.0.0')
    implementation('com.google.inject.extensions:guice-multibindings:4.2.3')
    implementation('commons-io:commons-io:2.16.1')
    // deps of guice
    implementation 'jakarta.inject:jakarta.inject-api:2.0.1'

    // logging
    implementation platform('org.apache.logging.log4j:log4j-bom:2.23.1')
    implementation 'org.slf4j:slf4j-api'
    implementation 'org.apache.logging.log4j:log4j-slf4j2-impl'
    implementation 'org.apache.logging.log4j:log4j-api'
    implementation 'org.apache.logging.log4j:log4j-core'
    // route apache commons logging to slf4j (commons configuration has transitive dep on that)
    implementation 'org.slf4j:jcl-over-slf4j:2.0.13'


    // event handling
    // is already present in guice
//    implementation('com.google.guava:guava:33.0.0-jre-jpms')

    // utils
    compileOnly 'org.projectlombok:lombok:1.18.28'
    annotationProcessor 'org.projectlombok:lombok:1.18.28'
    implementation('org.apache.commons:commons-configuration2:2.10.1') {
        exclude group: 'commons-logging', module: 'commons-logging'
    }
    implementation('org.apache.commons:commons-lang3:3.12.0')
    // some other dep depends on this
    implementation('commons-beanutils:commons-beanutils:1.9.4') {
        exclude group: 'commons-logging', module: 'commons-logging'
    }


    // testing
    testImplementation('org.testfx:testfx-core:4.0.18') {
        exclude module: 'hamcrest-all'
    }
    testImplementation('org.testfx:testfx-junit:4.0.18') {
        exclude module: 'hamcrest-core'
    }
    testImplementation('org.loadui:testFx:3.1.2')
    testImplementation('org.hamcrest:hamcrest-core:1.3')
    testImplementation('junit:junit:4.13.2')
}
