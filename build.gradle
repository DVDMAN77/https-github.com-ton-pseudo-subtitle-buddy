plugins {
    id 'java'
    id 'application'
//    pulls the correct platform dependent native libraries onto the classpath path
    id 'org.openjfx.javafxplugin' version '0.1.0'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'org.beryx.jlink' version '2.24.0'
}

group = 'io.github.vincemann'
version = '1.1.0'


application {
    mainModule = 'io.github.vincemann.subtitlebuddy'
    mainClass = 'io.github.vincemann.subtitlebuddy.Main'
}

ext {
    // Determine the OS name from the system property
    def osName = System.getProperty("os.name").toLowerCase()

    // Set default platform based on the OS
    def defaultPlatform = osName.contains("linux") ? "linux" :
            osName.contains("mac") || osName.contains("os x") ? "mac" :
                    osName.contains("win") ? "win" : "unknown"

    // Use the provided targetPlatform property if available, otherwise use the detected OS
    targetPlatform = project.hasProperty('targetPlatform') ? project.targetPlatform : defaultPlatform
}

javafx {
    version = "17"
    modules = ['javafx.controls', 'javafx.fxml']
    platform = targetPlatform
}


// for testing on windows, need to mkdir test/win/lib/javafx-sdk
// and put the windows javafx skd version 17 in this folder
test {
    doFirst {
        jvmArgs = [
                '--add-modules', javafx.modules.join(","),
                // javafx plugin fails for windows to pull the modules on test path and compile path maybe
                // or windows does not recognize, thats why I need to manually ship the native javafx sdk with it
                // and setup the module path in testing and when running the fat jar on windows
                '--module-path', "${projectDir}/test/win/lib/javafx-sdk/lib",
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED',
                "--add-exports", "org.apache.commons.logging/org.apache.commons.logging.impl=org.apache.commons.configuration2",
                //                resolve some issues with javafx and testfx
                '--add-exports', 'javafx.graphics/com.sun.javafx.application=org.testfx',
                '--add-opens', 'javafx.graphics/com.sun.javafx.application=org.testfx',

        ]
    }
}

jlink {
    options = ['--strip-debug', '--compress', '2', '--no-header-files', '--no-man-pages']

    targetPlatform("linux") {
        jdkHome = "/home/vince/.jdks/liberica-17.0.8"
    }

    targetPlatform("win") {
        jdkHome = "/home/vince/projekte/important/Subtitle-Buddy/testing/win/jre"
        addExtraModulePath("/home/vince/projekte/important/Subtitle-Buddy/testing/win/lib/javafx-sdk/lib")
    }
    launcher {
        name = 'appLauncher'
        mainClass = application.mainClass.get()
        jvmArgs = [
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED',
                '--add-reads', 'io.github.vincemann.merged.module=org.apache.commons.logging',
                '--add-reads', 'org.apache.commons.configuration2=io.github.vincemann.merged.module',
                "--add-exports", "org.apache.commons.logging/org.apache.commons.logging.impl=org.apache.commons.configuration2"
        ]
    }
}


// uses app image tool generating binary, which must be placed into: releases/linux/appimagetool.AppImage
// execute with -PtargetPlatform=linux
tasks.register('buildLinuxAppImage') {
    dependsOn('shadowJar')
    doLast {
        // Read version from generated jar file
        def jar = shadowJar.getArchiveFile().get().asFile
        def jarName = jar.name
        def version = project.version
        def jarPath = jar.absolutePath
        def baseDir = "${projectDir}/releases/linux/x64"
        def zipName = "subtitle-buddy-$version-linux-x64.zip"
        def linuxImageName = "subtitle-buddy-$version-linux-x64.AppImage"
        def zipOutputPath = "${baseDir}/$zipName"

        println "Jar file: $jarName"
        println "Version: $version"
        println "Jar path: $jarPath"

        // Linux x64 specifics
        println "linux x64..."
        def appImagePath = "${baseDir}/SubtitleBuddy.AppDir/usr/bin"
        delete "$appImagePath/application.jar"
        copy {
            from jarPath
            into appImagePath
            rename { 'application.jar' }
        }
        println "Jar copied"

        // Build AppImage
        println "Building app image"

        exec {
            environment "ARCH", "x86_64"
            commandLine 'bash', '-c', "cd ${baseDir} && ../appimagetool.AppImage SubtitleBuddy.AppDir $linuxImageName"
        }

        // Create ZIP of the binary
        delete zipOutputPath
        ant.zip(destFile: "$zipOutputPath", basedir: "${baseDir}", includes: "$linuxImageName")

        println "Done with linux x64"
    }
}

// uses a docker container with image name 'amake/innosetup' that uses wine for building windows installer from linux host machines
// execute with -PtargetPlatform=win
tasks.register('buildWindowsInstaller') {
    dependsOn('shadowJar')
    doLast {
        def jar = shadowJar.getArchiveFile().get().asFile
        def version = project.version
        def jarPath = jar.absolutePath
        def baseDir = "${projectDir}/releases/windows/x64"
        def installerPath = "${baseDir}/inno"
        def windowsImageName = "subtitle-buddy-installer.exe"
        def zipName = "subtitle-buddy-$version-windows-x64.zip"
        def zipOutputPath = "${baseDir}/$zipName"
        def outputExePath = "${installerPath}/output/${windowsImageName}"

        println "Jar file: ${jar.name}"
        println "Version: $version"
        println "Jar path: $jarPath"

        // Ensure target directories exist
        file(installerPath).mkdirs()

        // Deploy the jar to the installer directory
        delete "$installerPath/application.jar"
        copy {
            from jarPath
            into installerPath
            rename { 'application.jar' }
        }
        println "Deployed jar file to installer directory"

        // Building the installer using Inno Setup within a Docker container
        println "Building installer"
        exec {
            commandLine 'bash', '-c', "cd ${installerPath} && docker run --rm -i -v \"\$PWD:/work\" amake/innosetup subtitle-buddy.iss && mv ${outputExePath} ${baseDir}"
        }

        // Packaging into a zip file
        delete zipOutputPath
        ant.zip(destFile: "$zipOutputPath", basedir: "${baseDir}", includes: "$windowsImageName")

        println "Done with windows x64"
    }
}

// uses genisoimage linux cli tool, need to install it first
// execute with -PtargetPlatform=mac
tasks.register('buildMacDmg') {
    dependsOn 'shadowJar'
    doLast {
        def jar = shadowJar.getArchiveFile().get().asFile
        def jarName = jar.name
        def version = project.version
        def jarPath = jar.absolutePath
        def baseDir = "${projectDir}/releases/macos/x64"
        def appPath = "${baseDir}/SubtitleBuddy.app/Contents/Java"
        def dmgName = "subtitle-buddy-$version-macos-x64.dmg"
        def zipName = "subtitle-buddy-$version-macos-x64.zip"
        def dmgOutputPath = "${baseDir}/$dmgName"
        def zipOutputPath = "${baseDir}/$zipName"

        println "Jar file: $jarName"
        println "Version: $version"
        println "Jar path: $jarPath"

        // Ensure the application directory exists
        file(appPath).mkdirs()

        // Copy the JAR to the application directory
        println "Deploying jar file to application directory..."
        file("$appPath/application.jar").delete()
        copy {
            from jarPath
            into appPath
            rename { 'application.jar' }
        }
        println "Jar copied"

        // Build DMG
        println "Building DMG image..."
        exec {
            commandLine 'bash', '-c', "cd ${baseDir} && genisoimage -D -V SubtitleBuddy -no-pad -r -apple -o ${dmgOutputPath} SubtitleBuddy.app/"
        }

        // Create ZIP of the binary
        println "Creating ZIP archive..."
        delete zipOutputPath
        ant.zip(destFile: "$zipOutputPath", basedir: "${baseDir}", includes: "$dmgName")
        println "Done with macOS x64"
    }
}


java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
    modularity.inferModulePath.set(true)
}

shadowJar {
    archiveClassifier.set('')
    archiveFileName = "SubtitleBuddy-${project.version}-${targetPlatform}.jar"
    manifest {
        attributes 'Main-Class': application.getMainClass().get()
    }
    mergeServiceFiles {}
    // this removes needed classes for slf4j, making dynamic class loading of slf4j impl fail
//    minimize()  // Optional: minimize the jar to remove unused classes
}

startShadowScripts {
    doLast {
        // Modify the script file to point to the correct directory
        unixScript.text = unixScript.text.replace('lib/', 'libs/')
        windowsScript.text = windowsScript.text.replace('lib\\', 'libs\\')
    }
}

repositories {
    mavenCentral()
    maven {
        url "https://jpms.pkg.st/repository"
    }
}

// same as: java --add-modules javafx.controls,javafx.fxml -jar /path/to/myjar.jar
// in windows this command in cli is needed java --module-path /path/to/javafx-sdk/lib --add-modules javafx.controls,javafx.fxml -jar /path/to/myjar.jar
run {
    doFirst {
        jvmArgs = [
                // modules are not part of sdk anymore - need to add them manually to module graph
                "--add-modules", javafx.modules.join(","),
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED',
                "--add-exports", "org.apache.commons.logging/org.apache.commons.logging.impl=org.apache.commons.configuration2"
        ]
    }
}

dependencies {

    // capture mouse and keyboard events
//    implementation 'com.1stleg:jnativehook:2.0.2'
    // need to use old version bc of segfaults on linux + keyboard strokes not working
    // needed to self modularize the jar in order to include for whatever reason + this way I can build a custom jlink image
    // bc cant use automatic modules in jlink
    implementation files('lib/jnativehook-2.0.2-patched.jar')

    // dependency injection
    implementation('com.google.inject:guice:7.0.0')
    implementation('com.google.inject.extensions:guice-assistedinject:7.0.0')
    implementation('com.google.inject.extensions:guice-multibindings:4.2.3')
    implementation('commons-io:commons-io:2.16.1')
    // deps of guice
    implementation 'jakarta.inject:jakarta.inject-api:2.0.1'

    // logging
    implementation platform('org.apache.logging.log4j:log4j-bom:2.23.1')
    implementation 'org.slf4j:slf4j-api'
    implementation 'org.apache.logging.log4j:log4j-slf4j2-impl'
    implementation 'org.apache.logging.log4j:log4j-api'
    implementation 'org.apache.logging.log4j:log4j-core'
    // route apache commons logging to slf4j (commons configuration has transitive dep on that)
    implementation 'org.slf4j:jcl-over-slf4j:2.0.13'


    // event handling
    // is already present in guice
//    implementation('com.google.guava:guava:33.0.0-jre-jpms')

    // utils
    compileOnly 'org.projectlombok:lombok:1.18.28'
    annotationProcessor 'org.projectlombok:lombok:1.18.28'
    implementation('org.apache.commons:commons-configuration2:2.10.1') {
        exclude group: 'commons-logging', module: 'commons-logging'
    }
    implementation('org.apache.commons:commons-lang3:3.12.0')
    // some other dep depends on this
    implementation('commons-beanutils:commons-beanutils:1.9.4') {
        exclude group: 'commons-logging', module: 'commons-logging'
    }
//    implementation 'commons-logging:commons-logging:1.3.1'


    // testing
    testImplementation('org.testfx:testfx-core:4.0.18') {
        exclude module: 'hamcrest-all'
    }
    testImplementation('org.testfx:testfx-junit:4.0.18') {
        exclude module: 'hamcrest-core'
    }
    testImplementation('org.loadui:testFx:3.1.2')
    testImplementation('org.hamcrest:hamcrest-core:1.3')
    testImplementation('junit:junit:4.13.2')
}
