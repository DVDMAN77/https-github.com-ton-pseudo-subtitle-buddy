import java.nio.file.Paths
import java.util.zip.ZipFile

plugins {
    id 'java'
    id 'application'
//    pulls the correct platform dependent native libraries on the module path
    id 'org.openjfx.javafxplugin' version '0.1.0'
}

group = 'io.github.vincemann'
version = '1.1.0'

// provides main module and class - analog to:
// --module io.github.vincemann.subtitlebuddy/io.github.vincemann.subtitlebuddy.Main
application {
    setMainModule('io.github.vincemann.subtitlebuddy')
    setMainClass('io.github.vincemann.subtitlebuddy.Main')
}

compileJava {
    doFirst {
        options.compilerArgs = [
                '--module-path', project.ext.compileModulePath.call() + "",
                '--add-modules', project.ext.rootModules.call().join(",")
        ]
    }
}


compileTestJava {
    doFirst {
        options.compilerArgs = [
                '--module-path', project.ext.compileTestModulePath.call(),
                '--add-modules', project.ext.testRootModules.call().join(",")
//                '--patch-module', 'com.google.guice=${sourceSets.test.java.srcDirs.first()}'
        ]
    }
}


ext {
    // Default to linux platform if not provided [linux, mac, win]
    targetPlatform = project.hasProperty('targetPlatform') ? project.targetPlatform : 'linux'

    // module dependencies for modules I modularized myself are in the jmods folder (automatic or named modules)
    runtimeModulePath = {
        return sourceSets.main.runtimeClasspath.asPath
    }
    compileModulePath = {
        return sourceSets.main.compileClasspath.asPath
    }

    runtimeTestModulePath = {
        return sourceSets.test.runtimeClasspath.asPath
    }
    compileTestModulePath = {
        return sourceSets.test.compileClasspath.asPath
    }

    rootModules = {
        def modules = new ArrayList()
        modules.addAll(javafx.getModules())
        modules.add(application.mainModule.get())
        return modules
    }

    testRootModules = {
        def modules = new ArrayList()
        modules.addAll(javafx.getModules())
        modules.add('io.github.vincemann.subtitlebuddy.test')
        return modules
    }
}

jar {
    doFirst {
        archiveClassifier.set('')
        archiveFileName = "SubtitleBuddy-${project.version}-${targetPlatform}.jar"
    }
    manifest {
        attributes(
                'Main-Class': application.getMainClass().get()
        )
    }
}

test {
    doFirst {
        jvmArgs = [
                "--module-path", project.ext.runtimeTestModulePath.call(),
                '--add-modules', project.ext.testRootModules.call().join(','),
//                resolve some issues with javafx and testfx
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED',
                '--add-exports', 'javafx.graphics/com.sun.javafx.application=org.testfx',
                '--add-opens', 'javafx.graphics/com.sun.javafx.application=org.testfx'
        ]
    }
}

// Task to run 'jdeps' and capture its output
tasks.register("generateModuleInfo", Exec) {
    dependsOn 'jar'
    doFirst {
        // Ensure the directory is created before running the command
        mkdir 'build/tmp'
        // Determine the jar file path just before running the command
        def jarfilePath = jar.getArchiveFile().get().getAsFile().toPath().toAbsolutePath().toString()
        println("JAR File Path: " + jarfilePath)

        def rootModules = project.ext.rootModules.call().join(",")
        println("root modules: " + rootModules)

        // Configure the commandLine here to use the up-to-date jar file path
        commandLine 'jdeps',
                '--module-path', project.ext.runtimeModulePath.call(),
                '--add-modules', rootModules,
                '--multi-release', '9',
                '--print-module-deps',
                jarfilePath
    }
    standardOutput = new ByteArrayOutputStream()

    doLast {
        // Save the output to a file for later use
        def outputFile = file('build/tmp/deps.txt')
        outputFile.text = standardOutput.toString()
        println("Saved jdeps output to: ${outputFile.path}")
    }
}

// create minimal runtime image, only containing the modules needed for the application
// also ships jdk modules needed -> standalone executable
tasks.register("createRuntimeImage", Exec) {
    dependsOn 'generateModuleInfo'
    doFirst {
        def deps = file('build/tmp/deps.txt').text.trim()
        println("Modules to include: " + deps)

        commandLine 'jlink',
                '--module-path', project.ext.runtimeModulePath.call(),
                '--add-modules', deps,
                '--output', 'build/image',
                '--strip-debug',
                '--compress', '2',
                '--no-header-files',
                '--no-man-pages'
    }
}

task listAutomaticModules {
    doLast {
        // Define a closure to check if a JAR file contains module-info.class
        def containsModuleInfo = { File jar ->
            try {
                ZipFile zipFile = new ZipFile(jar)
                def hasModuleInfo = zipFile.entries().asIterator().any { entry ->
                    entry.name.endsWith("module-info.class")
                }
                zipFile.close()
                return hasModuleInfo
            } catch (IOException e) {
                println("Error reading file: ${jar}")
                return false
            }
        }

        // List to hold the names of automatic modules
        def automaticModules = []
        def automaticModulesPaths = []

        // Check all files in the runtime classpath
        configurations.runtimeClasspath.files.each { File file ->
            if (file.name.endsWith('.jar') && !containsModuleInfo(file)) {
                // Assuming the jar is an automatic module if it does not contain module-info.class
                String moduleName = file.name.take(file.name.lastIndexOf('.')).replaceAll(/[-\.]/, '_')
                String path = file.toPath().toAbsolutePath().toString()
                automaticModules.add(moduleName)
                automaticModulesPaths.add(path)
            }
        }

        // Print out all detected automatic modules
        if (automaticModules.isEmpty()) {
            println("No automatic modules found.")
        } else {
            println("Found automatic modules:")
            automaticModules.each { println(it) }
            automaticModulesPaths.each { println(it) }
        }
    }
}

tasks.register('writeModulePath') {
    doLast {
        // Create a file object for the module path file
        def modulePathFile = file('modulepath')

        // Get the module path from the runtime classpath
        def modulePath = project.sourceSets.main.runtimeClasspath.asPath

        // Write the module path to the file
        modulePathFile.text = modulePath

        // Optional: Print the module path to the console for verification
        println("Module path written to file: ${modulePathFile.path}")
        println("Module Path: \n$modulePath")
    }
}

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(11))
    }
//    makes sure module path is correctly set up
    modularity.inferModulePath.set(true)
}


run {
    doFirst {
        println "Module path: " + project.ext.runtimeModulePath.call()+""
        jvmArgs = [
                "--module-path", project.ext.runtimeModulePath.call(),
                // modules are not part of sdk anymore - need to add them manually to module graph
                "--add-modules", project.ext.rootModules.call().join(","),
                '--add-reads', 'org.apache.commons.configuration2=ALL-UNNAMED',
        ]
    }
}

javafx {
    version = "11"
    modules = ['javafx.controls', 'javafx.fxml']
    platform = targetPlatform
}

repositories {
    mavenCentral()
    maven {
        url "https://jpms.pkg.st/repository"
    }
}

//tasks.withType(AbstractCopyTask) {
//    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
//}

dependencies {

    // need to use old version bc of segfaults on linux + keyboard strokes not working
    // needed to self modularize the jar in order to include for whatever reason + this way I can build a custom jlink image
    // bc cant use automatic modules in jlink
    implementation files('lib/jnativehook-2.0.2-patched.jar')
//    implementation files('lib/guice-7.0.0.jar')
    // deps of guice
    implementation 'jakarta.inject:jakarta.inject-api:2.0.1'
//    implementation 'com.google.guava:guava:23.6-jre'
//    implementation 'com.google.j2objc:j2objc-annotations:1.1'
//    implementation 'aopalliance:aopalliance:1.0'
//    implementation 'com.google.errorprone:error_prone_annotations:2.26.1'
//    implementation 'org.ow2.asm:asm:6.0'
//    implementation 'com.google.code.findbugs:jsr305:3.0.1'


    // dependency injection
    implementation('com.google.inject:guice:7.0.0'){
        exclude module: 'guava'
    }
    implementation('com.google.inject.extensions:guice-assistedinject:7.0.0')
    implementation('com.google.inject.extensions:guice-multibindings:4.2.3')
    implementation('commons-io:commons-io:2.16.1')

    // logging
    implementation platform('org.apache.logging.log4j:log4j-bom:2.23.1')
    implementation 'org.slf4j:slf4j-api'
    implementation 'org.apache.logging.log4j:log4j-slf4j2-impl'
    implementation 'org.apache.logging.log4j:log4j-api'
    runtimeOnly 'org.apache.logging.log4j:log4j-core'

    // mostly needed as a transitive dep of guice and eventhandling
    implementation('com.google.guava:guava:33.0.0-jre-jpms')

    // utils
    // only needed for compilation - not at runtime
    implementation 'org.projectlombok:lombok:1.18.28'
    annotationProcessor 'org.projectlombok:lombok:1.18.28'
    implementation('org.apache.commons:commons-configuration2:2.10.1')
    implementation('org.apache.commons:commons-lang3:3.12.0')
    // some other dep depends on this
    implementation 'commons-beanutils:commons-beanutils:1.9.4'


    // TESTING
    testImplementation('org.testfx:testfx-core:4.0.18') {
        exclude module: 'hamcrest-all'
    }
    testImplementation('org.testfx:testfx-junit:4.0.18') {
        exclude module: 'hamcrest-core'
    }
    testImplementation('org.loadui:testFx:3.1.2') {
        exclude module: 'hamcrest-all'
    }
    testImplementation('org.hamcrest:hamcrest-core:1.3')

    testImplementation('junit:junit:4.13.2') {
        exclude group: 'org.hamcrest'
    }


}
